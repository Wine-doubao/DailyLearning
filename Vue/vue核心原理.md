## 响应式

### 双向数据绑定

Vue是采用`数据劫持`结合`发布者-订阅者模式`的方式来实现双向数据绑定的。

当Vue实例创建时，Vue会遍历data中的属性，用Object.defineProperty（vue3.0使用proxy）将它们转化为getter/setter，在数据变动时发布消息给订阅者，触发相应的监听回调。每个组件实例都有相应的 watcher 实例。主要分为以下几个步骤：

1. 需要Observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter/getter，给这个对象的某个值赋值，就会触发setter，这样就可以监听到数据变化。
2. Compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，`添加监听数据的订阅者`，一旦数据有变动，收到通知，更新视图。
3. Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: 
   1. 在自身实例化时往订阅器管理员(dep)里面添加自己
   2. 自身必须有一个update()方法，待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退

![image-20220308201858759](https://gitee.com/jolinfor/picture-bed/raw/master/img/image-20220308201858759.png)

### Object.defineProperty与Proxy

**Object.defineProperty缺点**：

1. 无法监听数组的变化，Vue内部通过重写数组的8种方法来检测数组变化。除了这8种，其他数组属性都检测不到，比如`通过下标方式修改数组数据`或者`给对象新增属性`，这都不能触发组件的重新渲染。
2. 只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历。

在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。

**Proxy的优点**：

1. Proxy可以直接劫持整个对象，并返回一个新对象，不管是操作便利程度还是底层功能都远胜Object.defineProperty。
2. Proxy可以无压力监听数组的变化。
3. Proxy有13中拦截方式，是Object.defineProperty不具备的。
4. 如果对象在vue实例创建后新增属性，一样可以监听到，不需要使用`Vue.$set` 或 `Vue.$delete` 触发响应式。
5. 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示。

Proxy 唯一的缺点是兼容性的问题，因为它是 ES6 的语法。



可参考[面试官: 实现双向绑定Proxy比defineproperty优劣如何?](https://juejin.cn/post/6844903601416978439)





## Vue模板编译





## 虚拟DOM

从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。其设计最初的目的就是跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，使用vue内部封装的diff算法来比较现在的虚拟DOM会与缓存的虚拟DOM，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。

### 为什么要用虚拟DOM？

1. Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。
2. 跨平台：Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。

### Diff算法原理

**Vnode最大的用途就是在数据变化前后生成真实DOM对应的虚拟DOM节点，然后就可以对比新旧两份VNode，找出差异所在，然后更新有差异的DOM节点，最终达到以最少操作真实DOM更新视图的目的。**

在新老虚拟DOM对比时：

- 首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换
- 如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
- 比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。
- 匹配时，找到相同的子节点，递归比较子节点

在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。

### Vue中key的作用

vue 中 key 值的作用可以分为两种情况来考虑：

- 第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。
- 第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。

key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速

- 更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。
- 更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快

diff算法的过程中，先会进行新旧节点的首尾交叉对比，当无法匹配的时候会用新节点的key与旧节点进行对比，从而找到相应的旧节点。

#### 为什么不建议用index作为key？

使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。