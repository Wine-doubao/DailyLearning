算法就是解决问题的办法/步骤逻辑。

## 排序算法

![cde64bf682850738153e6c76dd3f6fb32201ce3c73c23415451da1eead9eb7cb-20190624173156](https://s2.loli.net/2022/03/27/64pUV9RWarzNwDZ.png)

1. 冒泡排序

2. 选择排序

3. 插入排序

4. 快速排序

5. 堆排序

   - 堆的特点：要是一颗`完全二叉树`；堆上的每个节点要满足父节点的值要比子节点的值大（或小）

   - 一个已经排好序的堆可以用一个数组来按顺序存储每个节点的值，对当前节点所在位置 i（堆顶位置为0），其父子节点位置满足：

     - parent：`(i-1)/2`，向下取整
     - children1：`2i+1`
     - children2：`2i+2`

   - 大根堆即每个节点的值>=子节点的值，在堆排序算法中用于**升序排列**；小根堆相反，用于**降序排列**；堆排序的平均时间复杂度为O(nlogn)。

   - `堆排序`：

     1. 创建一个堆 H[0...n-1]

        - 对一颗深度为 h 的完全二叉树，从 h-1 行开始**从右到左**对每个非叶子节点做一次 heapify

        - heapify：找出当前节点及其子节点中的最大值，如果大于当前节点的值，则将其与最大值交换，保证父节点的值比子节点的值。因为交换了节点，也可能对下面子树产生影响（比如交换下来的那个数是子树中最小的），这个时候就要**使用递归对下面的子树再heapify一次**！！

          ![image-20220226100605495](https://s2.loli.net/2022/03/27/nJiAuNPs3dzmYk2.png)

     2. 将堆首和队尾交换，并把堆的尺寸缩小1，调整堆

     3. 循环上述步骤，直到堆的尺寸为1
   
   - **求前 k 大，用小根堆，求前 k 小，用大根堆**。如果求前 k 大用大根堆的话，那就要把所有元素都压入堆，然后再排出前k个最大的，这样时间复杂度就是 O(nlogn)；如果用小根堆，就只要将前 [0...k-1] 个元素压入堆，然后从 k 开始与堆顶比较，因为小根堆的堆顶是最小的，如果比堆顶还小，说明这个数肯定不属于前 k 大，如果比堆顶大，则与堆顶交换，再进行一次heapify调整小根堆，一直循环到数组尾部，这样得出来的前 K 个肯定是后面最大的，且时间复杂度为 O(nlogk)。 
   
   ```javascript
   var len; // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量
   
   function buildMaxHeap(arr) { // 建立大顶堆
     len = arr.length;
     // 找到 h-1 层的最右边的非叶子节点,len-2 表示最后一个节点(len-1)再减一除以2
     for (var i = Math.floor((len - 2) / 2); i >= 0; i--) {
       heapify(arr, i);
     }
   }
   
   function heapify(arr, i) { // 堆调整
     var left = 2 * i + 1,
         right = 2 * i + 2,
         largest = i;
   
    	// 注：这里不能用 i 替换 largest，因为可能覆盖前面一个找到的最大的
     // 如 5 7 6，用 i 则 largest=6 就会替换 largest=7
     if (left < len && arr[left] > arr[largest]) {
       largest = left;
     }
   
     if (right < len && arr[right] > arr[largest]) {
       largest = right;
     }
   
     if (largest != i) {
       swap(arr, i, largest);
       // 注：将小的调整下去，但可能这个值是最小的，所以要往下继续调整！！！
       heapify(arr, largest);
     }
   }
   
   function swap(arr, i, j) {
     var temp = arr[i];
     arr[i] = arr[j];
     arr[j] = temp;
   }
   
   function heapSort(arr) {
     buildMaxHeap(arr);
   
     // 注：这里要用arr.length，因为len在不断改变
     for (var i = arr.length - 1; i > 0; i--) {
       //为什么要交换位置？
       //将最大值与最后一个节点交换是因为排序是在当前数组进行的，这样就把最大值放在了数组len-1处，再对arr[0...len-2]部分进行堆排序
       swap(arr, 0, i);
       len--;
       //为什么直接从0位置（跟节点）heapify，而不是从(len-2)/2处开始？
       //因为除了根节点以外，其他节点都保持堆结构的特性，就相当于创建堆时，1到(len-2)/2部分的heapify工作已经做好了
       heapify(arr, 0);
     }
     return arr;
   }
   
   let arr = [1,10,8,3,4,6,7];
   heapSort(arr);
console.log(arr);
   ```

6. 桶排序

7. 归并排序

   - 该算法采用分治思想：排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

   - 有两种实现方法：自上而下的递归、自下而上的迭代。

   - **自上而下的递归**：

     - 时间复杂度为`O(nlogn)`：每一层归并的时间复杂度为O(n)；归并层数最大为O(logn+1)，因为二分。

     - 空间复杂度：

       - 如果是对数组做归并排序，则空间复杂度为`O(n)`，因为需要新开辟数组存放中间结果O(n)+递归函数调用O(logn)；
       - 如果是链表，则为`O(logn)`，因为链表可以通过修改引用来更改节点顺序，无需开辟额外空间，只需要递归调用的O(logn)

       ![image-20220309101245227](https://s2.loli.net/2022/03/27/lU4WCxtaGQ61FjY.png)

   - **自下而上的迭代**：

     - 对于非递归的归并排序，需要使用迭代的方法替换cut环节
     - 时间复杂度：`O(nlogn)`，空间复杂度：如果是数组，则为`O(n)`；如果是链表，则为`O(1)`。

     ![c1d5347aa56648afdec22372ee0ed13cf4c25347bd2bb9727b09327ce04360c2-Picture1](https://s2.loli.net/2022/03/27/Z9XmlhpvQrdIxOR.png)

   ```javascript
   // 自上而下的递归
   const mergeSort = arr => {
     const len = arr.length;
     if (len < 2) {
       return arr;
     }
     // length >> 1 和 Math.floor(len / 2) 等价
     let middle = Math.floor(len / 2),
         left = arr.slice(0, middle),
         right = arr.slice(middle); // 拆分为两个子数组
     return merge(mergeSort(left), mergeSort(right));
   };
   
   const merge = (left, right) => {
     const result = [];
     while (left.length && right.length) {
       // 注意: 判断的条件是小于或等于，如果只是小于，那么排序将不稳定.
       if (left[0] <= right[0]) {
         result.push(left.shift());
       } else {
         result.push(right.shift());
       }
     }
     while (left.length) result.push(left.shift());
     while (right.length) result.push(right.shift());
     return result;
   };
   ```

8. 希尔排序