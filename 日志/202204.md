## 4.23

明天要腾讯笔试，这几天都没好好刷题，不过还是有点期待，看看明天能做出多少题，二叉树，数组，链表的题应该可以做大部分？动态规划看了一下解题大致流程：找出最优子结构，构造状态转移方程，使用DP数组优化...怀疑明天会被虐🤡。

今天看了使用css实现三角形的6种方式，border、linear-gradient、conic-gradient、transform+hidden、clip-path、字符编码。

还看了Symbol：

- 用来表示唯一的值，它的引入主要是解决对象属性命名冲突的问题
- 使用Symbol函数创建唯一的Symbol值，不能使用new操作符，且不能自动转化为字符串
- 对象的Symbol属性可以使用Object.hasOwnPropertySymbols()或Reflect.ownKeys()来获取
- Symbol.for()全局搜索被登记的Symbol中是否有该字符串参数作为名称的Symbol值，如果有则返回该值，若没有则新建并返回一个以该字符串参数为名称的Symbol值，并登记在全局环境中供搜索
- Symbol.keyFor(参数为Symbol变量) 返回一个已登记的 Symbol 类型值的 key ，用来检测该字符串参数作为名称的 Symbol 值是否已被登记
- ES6还提供了11个内置的Symbol值...
- 使用场景：定义类的私有属性/方法；注册和获取全局Symbol，如页面中使用了iframe，Symbol.for()可以在所有这些window环境下保持一个共享的Symbol

今天就看了这么点...痛心疾首😶

## 4.20-2.22

居然中间隔了两天没写，emmm...昨天收到字节的面试邀请，好紧张我已经开始焦虑了😭，这两天没头没脑的不知道复习了什么，先搞定项目吧，可以项目当时遇到的问题给忘掉了，没有记录下来！！！要养成记录的好习惯，这些琐细的点写在日志里也是个参考的依据呀呜呜呜呜🙊，哦差点忘了后天晚上的腾讯笔试，赶一块了，还是面试的压力大些，relax~🍝

## 4.19

看着昨天的日志，感觉一天过的好快，明天五点多就要爬起来做核酸，其实说不上开心不开心，明天早起希望能有精神写算法吧。

今天写了两道差分数组的算法，这种技巧就是会者不难难者不会。下午去了个先进个人的表彰会，又是没有摸到鱼的一个下午。晚上看了flex和grid属性，sad，没记下来🤡，明天找空闲时间强化下记忆。

## 4.18

今天干什么了...3道算法题看了一天😅，明天不好好学习就是小🐖。

## 4.17

上午十一点多收到学长的模拟面试消息，虽然前几天已经说过了，但还是有些秃然🥝。从收到消息的紧张 -> 慢慢接受等待到来 -> 要开始，紧张坏了 -> 自我抛弃，有啥说啥。虽然中间有几次卡壳🍇...学长很温柔耐心，nice🍱。

感受最大的就是其实每一个问题对我来说都是开放题，问了解什么东西，讲一下，就一下子懵掉了，面经背多了，没有细节提醒都不知道从哪说起，要说些什么，逻辑思维还是很重要的，感觉我就属于催一下动一下的类型，惭愧🎃，就得主动说，多说点...

二轮复习规划：就着知识点归纳出一套逻辑，问到的时候要怎么答；去尝试各种奇奇怪怪的API，用熟来，也不至于把hasOwnProperty写成其他的还一直套😬，手写题很多都是方法、API的重写，还有各种应用题+算法。

## 4.16

上次写日志还是在去年，自己是最了解自己的，总得找点方法逼一逼自己，那就写日志每天update一下吧🤪。有些细小的收获凑一篇博客的子树是不够的，也就是心里的一点所想，又不想用又臭又长的无序列表来放在一个文件里，无头无脑，烦人的很，不如记录在每天的日志中，学习了什么，收获了什么，与日志最配的就是可爱的小表情啦😝

今天同学问了一道节流题为啥要用闭包的特性，去翻了下闭包的定义，毕竟被这个问题困扰很久了，究竟是要return了内部函数算数呢，还是只要在函数中定义了内部函数就算？希望来个面试官现场指导...MDN原话：当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。所以**闭包应该就是在定义这个函数的词法作用域外还能被调用的函数**（属于前者）。

还有一个问题就是为什么节流在时间到了的时候要执行`fn.apply(this, arguments)`，节流函数调用过程就是：把要节流的函数传入节流函数throttle，然后每次实际执行的是throttle返回的匿名函数。fn.apply干了啥事呢？将调用匿名函数的调用者作为this传给fn，并把可能传过来的参数给fn（传参这部分不怎么懂，这里应该是resize事件默认传的一个event参数）。一不小心写多了🍱

```html
<div class="container"></div>
<script>
  function throttle(fn, wait) {
    let curtime = 0;
    return function () {
      let context = this;
      let args = arguments;
      // console.log(args[0]);
      nowtime = Date.now();
      if (nowtime - curtime >= wait) {
        curtime = nowtime;
        return fn.apply(context, args)
      }
    }
  }
  // 模拟需要节流的目标函数
  function sayHi(e) {
    console.log(e.target.innerWidth, e.target.innerHeight);
  }
  // 全局状态下监听窗口大小
  window.onresize = throttle(sayHi,3000);
</script>
```

