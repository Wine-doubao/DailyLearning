## 4.16

上次写日志还是在去年，自己是最了解自己的，总得找点方法逼一逼自己，那就写日志每天update一下吧🤪。有些细小的收获凑一篇博客的子树是不够的，也就是心里的一点所想，又不想用又臭又长的无序列表来放在一个文件里，无头无脑，烦人的很，不如记录在每天的日志中，学习了什么，收获了什么，与日志最配的就是可爱的小表情啦😝

今天同学问了一道节流题为啥要用闭包的特性，去翻了下闭包的定义，毕竟被这个问题困扰很久了，究竟是要return了内部函数算数呢，还是只要在函数中定义了内部函数就算？希望来个面试官现场指导...MDN原话：当内部函数以某一种方式被任何一个外部函数作用域访问时，一个闭包就产生了。所以**闭包应该就是在定义这个函数的词法作用域外还能被调用的函数**（属于前者）。

还有一个问题就是为什么节流在时间到了的时候要执行`fn.apply(this, arguments)`，节流函数调用过程就是：把要节流的函数传入节流函数throttle，然后每次实际执行的是throttle返回的匿名函数。fn.apply干了啥事呢？将调用匿名函数的调用者作为this传给fn，并把可能传过来的参数给fn（传参这部分不怎么懂，这里应该是resize事件默认传的一个event参数）。一不小心写多了🍱

```html
<div class="container"></div>
<script>
  function throttle(fn, wait) {
    let curtime = 0;
    return function () {
      let context = this;
      let args = arguments;
      // console.log(args[0]);
      nowtime = Date.now();
      if (nowtime - curtime >= wait) {
        curtime = nowtime;
        return fn.apply(context, args)
      }
    }
  }
  // 模拟需要节流的目标函数
  function sayHi(e) {
    console.log(e.target.innerWidth, e.target.innerHeight);
  }
  // 全局状态下监听窗口大小
  window.onresize = throttle(sayHi,3000);
</script>
```

